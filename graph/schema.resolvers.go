package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/jkzilla/egg/graph/model"
	"github.com/jkzilla/egg/signal"
)

// PurchaseEgg is the resolver for the purchaseEgg field.
func (r *mutationResolver) PurchaseEgg(ctx context.Context, id string, quantity int, paymentMethod *string, pickupTime *string) (*model.PurchaseResult, error) {
	r.mutex.Lock()
	defer r.mutex.Unlock()

	egg, exists := r.eggs[id]
	if !exists {
		return &model.PurchaseResult{
			Success:           false,
			Message:           "Egg not found",
			RemainingQuantity: 0,
		}, nil
	}

	if quantity <= 0 {
		return &model.PurchaseResult{
			Success:           false,
			Message:           "Quantity must be greater than 0",
			RemainingQuantity: egg.QuantityAvailable,
		}, nil
	}

	if egg.QuantityAvailable < quantity {
		return &model.PurchaseResult{
			Success:           false,
			Message:           fmt.Sprintf("Not enough eggs available. Only %d in stock", egg.QuantityAvailable),
			RemainingQuantity: egg.QuantityAvailable,
		}, nil
	}

	egg.QuantityAvailable -= quantity

	// Send Signal notification if cash payment
	if paymentMethod != nil && *paymentMethod == "cash" && pickupTime != nil {
		ownerPhone := os.Getenv("OWNER_PHONE_NUMBER")
		if ownerPhone != "" {
			totalPrice := float64(quantity) * egg.Price
			message := fmt.Sprintf(
				"New Cash Order!\n\nItem: %s\nQuantity: %d\nTotal: $%.2f\nPickup Time: %s\n\nPlease confirm with customer.",
				egg.Type,
				quantity,
				totalPrice,
				*pickupTime,
			)

			err := signal.SendMessage(ownerPhone, message)
			if err != nil {
				log.Printf("Failed to send Signal notification: %v", err)
				// Don't fail the purchase if notification fails
			} else {
				log.Printf("Signal notification sent successfully to %s", ownerPhone)
			}
		}
	}

	return &model.PurchaseResult{
		Success:           true,
		Message:           fmt.Sprintf("Successfully purchased %d egg(s) for $%.2f", quantity, float64(quantity)*egg.Price),
		RemainingQuantity: egg.QuantityAvailable,
	}, nil
}

// Eggs is the resolver for the eggs field.
func (r *queryResolver) Eggs(ctx context.Context) ([]*model.Egg, error) {
	r.mutex.RLock()
	defer r.mutex.RUnlock()

	eggs := make([]*model.Egg, 0, len(r.eggs))
	for _, egg := range r.eggs {
		eggs = append(eggs, egg)
	}
	return eggs, nil
}

// Egg is the resolver for the egg field.
func (r *queryResolver) Egg(ctx context.Context, id string) (*model.Egg, error) {
	r.mutex.RLock()
	defer r.mutex.RUnlock()

	egg, exists := r.eggs[id]
	if !exists {
		return nil, fmt.Errorf("egg with id %s not found", id)
	}
	return egg, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
